<!DOCTYPE html>
<!-- note, disable touch overscroll! https://www.addictivetips.com/web/disable-swipe-to-go-back-in-chrome/ -->
<html>

	<head>
		<title>Draw50</title>
		<meta name="viewport" content="width=device-width, user-scalable=no">

		<!-- font awesome for icons -->
		<link href="https://fonts.googleapis.com/css?family=Roboto+Condensed" rel="stylesheet">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

		<!-- custom style sheet -->
		<link rel="stylesheet" type="text/css" href="css/style.css">

		<!-- js libraries -->
		<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
		<script src="js/hammer.min.js"></script>
		<script src="js/paper-full.js"></script>
		<script type="text/javascript" canvas="touch-me">
		// defaults
		var path;
		var paths = [];
		var hidden = [];
		var undoAll = false;
		var emojis = ["â¤ï¸", "ğŸ˜€", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜", "ğŸ˜†", "ğŸ˜…", "ğŸ¤£", "ğŸ˜‚", "ğŸ™‚", "ğŸ™ƒ", "ğŸ˜‰", "ğŸ˜Š", "ğŸ˜‡", "ğŸ˜º", "ğŸ˜¸", "ğŸ˜¹", "ğŸ˜»", "ğŸ˜¼", "ğŸ˜½", "ğŸ™€", "ğŸ’Œ", "ğŸ’˜", "ğŸ’", "ğŸ’–", "ğŸ’—", "ğŸ’“", "ğŸ’", "ğŸ’•", "ğŸ‘", "âœ¨", "ğŸˆ", "ğŸ‰", "ğŸŠ", "ğŸ¦„", "â˜•", "ğŸ‘‘", "ğŸ’¥", "ğŸ’«", "ğŸ¤ ", "ğŸ‘»", "ğŸ‘½", "ğŸ‘¾", "ğŸ¤–", "ğŸ˜"];


		// pen defaults
		var backgroundColor = 'black';
		var defaultPenColor = 'white';
		var penColor = defaultPenColor;
		var defaultPenWeight = 4;
		var penWeight = defaultPenWeight;

		// eraser defaults
		var eraserColor = backgroundColor;
		var eraserWeight = 100;

		// time for menu to be out before hiding (in ms)
		var menuHideDelta = 3000;
		var menuLastTouched = -1;

		function undo() {
			// stop if there is nothing left to undo
			if (paths.length < 1) {
				return;
			}

			// swap arrays and make element invisible
			hidden.push(paths.pop());
			hidden[hidden.length - 1].visible = false;
			menuLastTouched = Date.now();
		}

		// function to redo last undo
		function redo() {
			if (hidden.length < 1) {
				return;
			}

			// swap arrays and make element visible
			paths.push(hidden.pop());
			paths[paths.length - 1].visible = true;
			menuLastTouched = Date.now();
		}

		// function to clear the screen
		function clearScreen() {
			paper.project.layers['defaultLayer'].removeChildren();
			paper.view.draw();
			hidden = [];
			paths = [];
			menuLastTouched = Date.now();
			clearEmojis();
		}

		function increasePen() {
			penWeight += 2;
			updateStrokeIndicator()
			menuLastTouched = Date.now();
		}

		function decreasePen() {
			// preserve minimum stroke of 5
			if (penWeight > 4){
				penWeight -= 2;
				updateStrokeIndicator()
			}
			menuLastTouched = Date.now();
		}

		function changePenColor(color) {
			penColor = color;
			updateStrokeIndicator()
			menuLastTouched = Date.now();
		}

		function resetPen() {
			penColor = defaultPenColor;
			penWeight = defaultPenWeight;
			updateStrokeIndicator()
			menuLastTouched = Date.now();
		}

		function showMenu() {
			menuLastTouched = Date.now();
			$("#custom").slideDown(400, function(){
				hideMenu();
			});
		}

		function updateStrokeIndicator() {
			$("#strokeIndicator").text(penWeight).css("color", penColor);
		}

		function clearEmojis() {
			try {
				paper.project.layers['emojiLayer'].removeChildren();
				paper.view.draw();
			} catch (e) {

			}
		}

		function hideMenu() {
			// base case if the menu is hidden
			if ($("#custom").css('display') == "none") {
				return;
			}

			// check if we're longer than the menu hide delta
			if (Date.now() - menuLastTouched > menuHideDelta) {
				$("#custom").slideUp();
			} else {
				// it hasn't been long enough, wait another second and check again
				setTimeout(hideMenu, 1000);
			}
		}

		function emojiRain(emojiCount) {
			// get the layer for emojis
			var layer = paper.project.layers['emojiLayer'];

			// if emojis are already placed, don't do it again
			if (layer.hasChildren()) {
				return;
			}
	

			// no emojis, it's emoji time
			layer.activate();
			let emojiSymbols = [];
			
			// turn emojis into symbols
			for (let i = 0; i < emojis.length; i++) {
				let e = new paper.PointText({
					content: emojis[i],
					center: [0.0],
					fontSize: "2em",
				});
				let s = new paper.Symbol(e);
				emojiSymbols.push(s);
			}
			
			// Iterate over the items
			for (var i = 0; i < emojiCount; i++) {

				// create a symbol from the emoji
				let symbol = emojiSymbols[Math.floor(Math.random() * emojiSymbols.length)];

				// place the emoji randomly on the view
				var center = new paper.Point(Math.floor(Math.random() * paper.view.size.width), Math.floor(Math.random() * paper.view.size.height));
				var placedSymbol = symbol.place(center);
				placedSymbol.scale(i / emojiCount);
			}

			// put emojis behind drawing
			layer.sendToBack();

			// activate the default layer so it's not tied to the emoji layer
			paper.project.layers['defaultLayer'].activate();
		}

		// The onFrame function is called up to 60 times a second:
			 
		// main function
		$(function() {

			// setup the canvas
			var canvas = document.getElementById('touch-me');
			paper.setup(canvas);
			$("#touch-me").css("background-color", backgroundColor);

			// display default size/color of the stroke in the menu
			updateStrokeIndicator();

			let layer = new paper.Layer();
			layer.name ="emojiLayer";

			layer = new paper.Layer();
			layer.name ="defaultLayer";

			// activate the default layer
			paper.project.layers['defaultLayer'].activate();

			// setup hammer.js for the bottom left corner for the secret menu
			var menuham = new Hammer.Manager(document.getElementById('mb'));
			var swipe = new Hammer.Swipe();
			menuham.add(swipe);

			// enable swipe at bottom left corner to show secret menu (auto-hides after 4 secs)
			menuham.on('swipeup', function() {
				showMenu();
			});

			// manually hide the menu
			menuham.on('swipedown', function() {
				$("#custom").slideUp();
			});

			// setup hammer.js for the main canvas
			mc = new Hammer.Manager(canvas);

			// handle 3-finger pan
			var pan = new Hammer.Pan({ pointers: 3 });
			mc.add(pan);

			mc.on('panmove', function(ev) {
				paper.project.activeLayer.position.x += ev.deltaX / 75;
				paper.project.activeLayer.position.y += ev.deltaY / 75;
			});

			// setup recognisers for 5 finger pinch
			var pinch = new Hammer.Pinch({ pointers: 5 });
			mc.add(pinch);

			mc.on('pinchin', function(ev) {
				paper.project.activeLayer.scale(0.99, new paper.Point(ev.center));
			});

			mc.on('pinchout', function(ev) {
				paper.project.activeLayer.scale(1.01, new paper.Point(ev.center));
			});

			// intercept all touch events to deal with 1 and 2 fingers
			mc.on('hammer.input', function(ev) {
				switch (ev.maxPointers) {

					// handle 1 finger
					case 1:

						// begin action on first press
						if (ev.isFirst) {
							path = new paper.Path({
								segments: [{ x: ev.center.x, y: ev.center.y }],
								strokeColor: penColor,
								strokeWidth: penWeight,
								strokeCap: 'round',
								fullySelected: false
							});
							paths.push(path);

							// now that we've restarted history, don't remember previous undos
							hidden = [];

						} else if (ev.isFinal) {
							// end draw
							paths[paths.length - 1].simplify(8);

							// special feature for pen touch
							if (ev.pointerType == 'pen') {
								// this is a five finger move of some kind, cue emojis
								emojiRain(250);
							}
						} else {
							// take action on the pointer moving
							paths[paths.length - 1].add({ x: ev.center.x, y: ev.center.y });
						}
						break;


					// process 2 fingers
					case 2:

						// begin action on first press (this is often not called beacause the first event is when the first finger lands, then the middle event - in the else condition here - fires next)
						if (ev.isFirst) {

							path = new paper.Path({
								segments: [{ x: ev.center.x, y: ev.center.y }],
								strokeColor: eraserColor,
								strokeWidth: eraserWeight,
								strokeCap: 'round',
								fullySelected: false
							});
							paths.push(path);

						// the last event of this stroke, do any cleanup
						} else if (ev.isFinal) {
							// we don't do any smoothing here, you don't want to smooth erasing
						// end action
						} else {
							// take action on the move

							// we color the path and change the weight here because the first event often fires with the single finger landing first
							paths[paths.length - 1].strokeColor = eraserColor;
							paths[paths.length - 1].strokeWidth = eraserWeight;

							// add the new point
							paths[paths.length - 1].add({ x: ev.center.x, y: ev.center.y });
						}
						break;

					case 3:
					case 4:
					case 5:
					case 6:
						// do nothing for 3-6 fingers here, handle in pinch mode
						break;
					case 7:
					case 8:
					case 9:
					case 10:
						// clear the screen on a press over

						// clear the screen when hands are raised
						if (ev.isFinal) {
							if (Math.abs(ev.deltaTime) > 400) {
								clearScreen();
							}
						}
						break;
					default:
						return;
				}
			});

			// function called on every frame, use this to animate emojis in the background if they exist
			paper.view.onFrame = function(event) {

				// Run through the active layer's children list and change
				// the position of the placed symbols:

				if (paper.project.layers['emojiLayer'].hasChildren()) {
					for (var i = 0; i < paper.project.layers['emojiLayer'].children.length; i++) {
						var item = paper.project.layers['emojiLayer'].children[i];
						
						// Move the item 1/20th of its width to the right. This way
						// larger circles move faster than smaller circles:
						item.position.x += item.bounds.width / 20;

						// If the item has left the view on the right, move it back
						// to the left:
						if (item.bounds.left > paper.view.size.width) {
							item.position.x = -item.bounds.width;
						}
					}
				}
			};

		});
		</script>
	</head>

	<body>
		<button class="top-left hidden corner" onclick="undo();"></button>
		<button class="top-right hidden corner" onclick="redo();"></button>
		<button id="mb" class="bottom-left hidden corner" onclick="undo();"></button>
		<button class="bottom-right hidden corner" onclick="redo();"></button>
		<canvas id="touch-me" resize></canvas>
		<div id="custom">
			<button class="menuButton" style="padding:5px;" onclick="resetPen();"><i class="fas fa-undo"></i></button>
			<button class="menuButton" onclick="increasePen();">+</button>
			<button class="menuButton" onclick="decreasePen();">-</button>
						<span id="strokeIndicator">test</span>

			<button class="menuButton dot red" onclick="changePenColor('red');"></button>
			<button class="menuButton dot green" onclick="changePenColor('green');"></button>
			<button class="menuButton dot orange" onclick="changePenColor('orange');"></button>
			<button class="menuButton dot yellow" onclick="changePenColor('yellow');"></button>
			<button class="menuButton dot blue" onclick="changePenColor('blue');"></button>
			<button class="menuButton dot white" onclick="changePenColor('white');"></button>
			<button class="menuButton" onclick="clearScreen();"><i class="fas fas fa-trash-alt"></i></button>

		</div>
	</body>
</html>
