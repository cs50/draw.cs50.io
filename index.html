<!DOCTYPE html>
<<<<<<< HEAD
<html>
<head>
<title>Draw50</title>
<meta name="Draw50" content="A simple drawing web app">
<link rel="shortcut icon" src="favicon.ico"/>
<!-- Load the Paper.js library -->
<link rel="stylesheet" src="css/main.css">
<script type="text/javascript" src="js/paper.js"></script>
<script type="text/javascript" src="js/hammer.min.js"></script>
<!-- Define inlined PaperScript associate it with myCanvas -->
<script type="text/paperscript" canvas="draw50Canvas">

  var path;
  var pathCreated = false;
  var canDraw = true;
  var onErase = false;

  var onDrawLine = false;
  var from;
  var to;

  var activeCanvas = document.getElementById('draw50Canvas');
  var undoArray = [];
  var drawDot = false;
  var didClearCanvas = false;
  var pathArray = {};

  // //Retrieving data:
  // try {
  //   var resumePath
  //   resumePath = localStorage.getItem("draw50");
  // } catch (error) {console.log(error)}

  // create a simple instance
  // by default, it only adds horizontal recognizers
  var mc = new Hammer.Manager(activeCanvas, {
    recognizers: [
      // RecognizerClass, [options], [recognizeWith, ...], [requireFailure, ...]
      [Hammer.Rotate, { enable: true, pointers: 0}],
      [Hammer.Pan, { pointers: 1 }],
      [Hammer.Tap],
      [Hammer.Pinch, { pointers: 0 }],
      [Hammer.Press]
    ]
  });

  // specifically deal with drawing dot scenarior, because we no longer trigger
  // drawing using "onMouseDown"
  mc.on('tap', function(ev) {
    canDraw = true;
    var dot = new Path.Circle(new Point(ev.center.x - 10,ev.center.y - 30), 10);
    dot.fillColor = 'white';
    project.activeLayer.addChild(dot);
  });

  // allow drawing if it is a 1-finger interaction
  mc.on('panmove', function(ev) {
    canDraw = true;
  });

  mc.on('press', function(ev) {
    console.log("pressing");
    onDrawLine = true;
    from = new Point(ev.center.x, ev.center.y);
  })

  // using "rotate" recognizer to detect multi-fingers situation
  mc.on("rotate", function(ev) {

    // 2 fingers for erasing
    if (ev.maxPointers === 2) {
      canDraw = true;
      onErase = true;
    };

    // suspending 3-finger action
    if (ev.maxPointers === 3) {
      canDraw = false;
      onErase = false;
    };

    // suspending 4-finger action
    if (ev.maxPointers === 4) {
      canDraw = false;
      onErase = false;
    };

    // 5 fingers for panning
    if (ev.maxPointers === 5) {
      canDraw = false;
      onErase = false;
      window.scrollBy(-ev.deltaX/20, -ev.deltaY/20);
    };

    // suspending 6-finger action
    if (ev.maxPointers === 6) {
      canDraw = false;
      onErase = false;
    };

    // 7+ fingers to clear canvas
    if (ev.maxPointers > 7 && Math.abs(ev.deltaTime) > 150) {
      project.activeLayer.removeChildren();
      canDraw = true;
      didClearCanvas = true;
      pathCreated = false;
    };

  });

  function onMouseDown(event) {};

  // drawing on canvas
  function onMouseDrag(event) {

    // prevent drawing for certain action
    if (!canDraw) {
      return;
    };

    didClearCanvas = false;

    // create path for the very first draw
    if (!pathCreated) {
      path = new Path();
      pathCreated = true;
    };

    if (onDrawLine) {
      return;
    }

    // when erasing, switch stroke color to black can start drawing
    // notice that we don't smooth path, because it is unnecessary
    if (onErase) {
      path.strokeColor = 'black';
      path.strokeWidth = 60;
      path.add(event.point);
      return;
    };

    // regular drawing
    path.strokeColor = 'white';
    path.strokeWidth = 10;
    path.add(event.point);
    path.smooth();

  };

  function onMouseUp(event) {

    // clean up path if it is not erasing

    if (onDrawLine) {
      to = new Point(event.point);
      path = new Path.Line(from, to);
      path.strokeWidth = 10;
      path.strokeColor = 'white';
      onDrawLine = false;
    }

    if (!onErase) {
      try {
        path.smooth();
        path.simplify(30);
      } catch (error) {};
    }

    onErase = false;

    // //Storing data:
    // localStorage.setItem('draw50', JSON.stringify(project.activeLayer._children));

    // create a new path for the next drawing
    path = new Path();
  };

  function undoPath() {
    try {
      var arrayLength = project.activeLayer._children.length;
      undoArray.push(project.activeLayer._children[arrayLength-2]);
      project.activeLayer._children[arrayLength-2].remove();
    } catch (error) {}
  }

  function redoPath() {
    try {
      project.activeLayer.addChild(undoArray[undoArray.length - 1]);
      undoArray.pop();
    } catch (error) {}
  }

  try {
    document.getElementById('undo').onclick = function() {
      undoPath();
    };

    document.getElementById('redo').onclick = function() {
      redoPath();
    };
  } catch (error) {};

</script>

</head>
<body>
  <button id="undo">Tap this to Undo </button>
  <button id="redo">Tap this to Redo </button>
  <canvas id="draw50Canvas" width=1920 height=3240 style="background-color: black"></canvas>
</body>
</html>
=======
<!-- note, disable touch overscroll! https://www.addictivetips.com/web/disable-swipe-to-go-back-in-chrome/ -->
<html>

	<head>
		<title>Draw50</title>
		<meta name="viewport" content="width=device-width, user-scalable=no">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">


		<style>
			html,
			body {
				height: 100%;
				width: 100%;
				margin: 0px;
				overflow: hidden;
			}

			/* Scale canvas with resize attribute to full size */
			canvas[resize] {
				width: 100%;
				height: 100%;
			}

			button.dot {
				height: 25px !important;
				width: 25px !important;
				border-radius: 50%;
				display: inline-block;
			}

			.red {
				background-color: red !important;
			}

			.white {
				background-color: white !important;
			}

			.green {
				background-color: green !important;
			}

			.yellow {
				background-color: yellow !important;
			}

			.orange {
				background-color: orange !important;
			}

			.blue {
				background-color: blue !important;
			}


			button.corner {
				height: 100px;
				width: 100px;
			}

			button.hidden {
				position: absolute;
				border: none !important;
				background: transparent !important;
				font-size: 0;
				outline: none;
			}

			button.top-left {
				top: 0px;
				left: 0px;
			}

			button.top-right {
				top: 0px;
				right: 0px;
			}

			button.bottom-left {
				bottom: 0px;
				left: 0px;
			}

			button.menuButton {
				height: 100%;
				width: 10%;
				color: white;
				font-size: 2em;
				background-color: black;
				text-align: center;
				outline: none;
				border: none !important;
				vertical-align: middle;
				line-height: 100%;
			}

			button.bottom-right {
				bottom: 0px;
				right: 0px;
			}

			div#custom {
				height: 40px;
				width: 500px;
				background-color: black;
				position: absolute;
				bottom: 0px;
				left: 5%;
				display: none;
			}
		</style>
		<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
		<script src="js/hammer.min.js"></script>
		<script src="js/paper-full.js"></script>
		<script type="text/javascript" canvas="touch-me">
		// defaults
		var path;
		var paths = [];
		var hidden = [];
		var undoAll = false;
		var emojis = ["â¤ï¸", "ğŸ˜€", "ğŸ˜ƒ", "ğŸ˜„", "ğŸ˜", "ğŸ˜†", "ğŸ˜…", "ğŸ¤£", "ğŸ˜‚", "ğŸ™‚", "ğŸ™ƒ", "ğŸ˜‰", "ğŸ˜Š", "ğŸ˜‡", "ğŸ˜º", "ğŸ˜¸", "ğŸ˜¹", "ğŸ˜»", "ğŸ˜¼", "ğŸ˜½", "ğŸ™€", "ğŸ’Œ", "ğŸ’˜", "ğŸ’", "ğŸ’–", "ğŸ’—", "ğŸ’“", "ğŸ’", "ğŸ’•", "ğŸ‘", "âœ¨", "ğŸˆ", "ğŸ‰", "ğŸŠ", "ğŸ¦„", "â˜•", "ğŸ‘‘", "ğŸ’¥", "ğŸ’«", "ğŸ¤ ", "ğŸ‘»", "ğŸ‘½", "ğŸ‘¾", "ğŸ¤–", "ğŸ˜"];


		// pen defaults
		var backgroundColor = 'black';
		var defaultPenColor = 'white';
		var penColor = defaultPenColor;
		var defaultPenWeight = 15;
		var penWeight = defaultPenWeight;

		// eraser defaults
		var eraserColor = backgroundColor;
		var eraserWeight = 100;

		function undo() {
			// stop if there is nothing left to undo
			if (paths.length < 1) {
				return;
			}

			// swap arrays and make element invisible
			hidden.push(paths.pop());
			hidden[hidden.length - 1].visible = false;

		}

		// function to redo last undo
		function redo() {
			if (hidden.length < 1) {
				return;
			}

			// swap arrays and make element visible
			paths.push(hidden.pop());
			paths[paths.length - 1].visible = true;
		}

		// function to clear the screen
		function clearScreen() {
			paper.project.clear();
			hidden = [];
			paths = [];
		}

		function increasePen() {
			penWeight += 5;
		}

		function decreasePen() {
			penWeight -= 5;
		}

		function changePenColor(color) {
			penColor = color;
		}

		function resetPen() {
			penColor = defaultPenColor;
			penWeight = defaultPenWeight;
		}

		// main function
		$(function() {

			// setup the canvas		
			var canvas = document.getElementById('touch-me');
			paper.setup(canvas);
			$("#touch-me").css("background-color", backgroundColor);

			// setup hammer.js for the bottom left corner for the secret menu
			var menuham = new Hammer.Manager(document.getElementById('mb'));
			var swipe = new Hammer.Swipe();
			menuham.add(swipe);

			// enable swipe at bottom left corner to show secret menu (auto-hides after 4 secs)
			menuham.on('swipeup', function() {
				$("#custom").slideDown().delay(4000).slideUp();
			});

			// manually hide the menu
			menuham.on('swipedown', function() {
				$("#custom").slideUp();
			});

			// setup hammer.js for the main canvas
			mc = new Hammer.Manager(canvas);

			// handle 3-finger pan
			var pan = new Hammer.Pan({ pointers: 3 });
			mc.add(pan);

			mc.on('panmove', function(ev) {
				console.log("pan", ev);
				paper.project.activeLayer.position.x += ev.deltaX / 75;
				paper.project.activeLayer.position.y += ev.deltaY / 75;
			});

			// setup recognisers for 5 finger pinch
			var pinch = new Hammer.Pinch({ pointers: 5 });
			mc.add(pinch);

			mc.on('pinchin', function(ev) {
				paper.project.activeLayer.scale(0.99, new paper.Point(ev.center));
			});

			mc.on('pinchout', function(ev) {
				paper.project.activeLayer.scale(1.01, new paper.Point(ev.center));
			});

			// intercept all touch events to deal with 1 and 2 fingers
			mc.on('hammer.input', function(ev) {
				switch (ev.maxPointers) {

					// handle 1 finger
					case 1:

						// begin action on first press
						if (ev.isFirst) {
							path = new paper.Path({
								segments: [{ x: ev.center.x, y: ev.center.y }],
								strokeColor: penColor,
								strokeWidth: penWeight,
								strokeCap: 'round',
								fullySelected: false
							});
							paths.push(path);

							// now that we've restarted history, don't remember previous undos
							hidden = [];

						} else if (ev.isFinal) {
							// end action
							paths[paths.length - 1].simplify(8);
						} else {
							// take action on the move
							paths[paths.length - 1].add({ x: ev.center.x, y: ev.center.y });
						}
						break;


					// process 2 fingers
					case 2:

						// begin action on first press (this is often not called beacause the first event is when the first finger lands, then the middle event - in the else condition here - fires next)
						if (ev.isFirst) {

							path = new paper.Path({
								segments: [{ x: ev.center.x, y: ev.center.y }],
								strokeColor: eraserColor,
								strokeWidth: eraserWeight,
								strokeCap: 'round',
								fullySelected: false
							});
							paths.push(path);

						// the last event of this stroke, do any cleanup
						} else if (ev.isFinal) {
							
						// end action
						} else {
							// take action on the move
							// console.log("middle2");

							// we color the path and change the weight here because the first event often fires with the single finger landing first
							paths[paths.length - 1].strokeColor = eraserColor;
							paths[paths.length - 1].strokeWidth = eraserWeight;

							// add the new point
							paths[paths.length - 1].add({ x: ev.center.x, y: ev.center.y });
						}
						break;

					case 3:
					case 4:
					case 5:
					case 6:
						// do nothing for 3-6 fingers here, handle in pinch mode
						break;
					case 7:
					case 8:
					case 9:
					case 10:
						// clear the screen on a press over 
						if (Math.abs(ev.deltaTime) > 400) {
							clearScreen();
						}
						break;
					default:
						return;
				}
			});

		});
		</script>
	</head>

	<body>
		<button class="top-left hidden corner" onclick="undo();"></button>
		<button class="top-right hidden corner" onclick="redo();"></button>
		<button id="mb" class="bottom-left hidden corner" onclick="undo();"></button>
		<button class="bottom-right hidden corner" onclick="redo();"></button>
		<canvas id="touch-me" resize></canvas>
		<div id="custom">
			<button class="menuButton" onclick="resetPen();"><i class="fas fa-undo"></i>

</button>
			<button class="menuButton" onclick="increasePen();">+</button>
			<button class="menuButton" onclick="increasePen();">-</button>
			<button class="menuButton dot red" onclick="changePenColor('red');"></button>
			<button class="menuButton dot green" onclick="changePenColor('green');"></button>
			<button class="menuButton dot orange" onclick="changePenColor('orange');"></button>
			<button class="menuButton dot yellow" onclick="changePenColor('yellow');"></button>
			<button class="menuButton dot blue" onclick="changePenColor('blue');"></button>
			<button class="menuButton dot white" onclick="changePenColor('white');"></button>
			<button class="menuButton" onclick="clearScreen();"><i class="fas fas fa-trash-alt"></i>

</button>
		</div>
	</body>
</html>
>>>>>>> master
